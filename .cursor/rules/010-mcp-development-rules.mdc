---
description: MCP Server Development Rules
globs: **/*
alwaysApply: true
---

# MCP Development Best Practices

- **Server Initialization Pattern**
  - Always import MCP server and transport from the correct paths
  - Initialize server with name, version, and optional capabilities
  - Connect using StdioServerTransport for Cursor integration

  ```javascript
  // ✅ DO: Follow this initialization pattern
  import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
  import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

  const server = new McpServer({
    name: "cursor10x",
    version: "2.0.0"
  });

  const transport = new StdioServerTransport();
  await server.connect(transport);

  // ❌ DON'T: Use incorrect imports or omit version information
  import { McpServer } from "@modelcontextprotocol/sdk"; // Wrong import path
  const server = new McpServer({ name: "cursor10x" }); // Missing version
  ```

- **Tool Registration**
  - Use Zod for schema validation
  - Organize tool registrations by domain/functionality
  - Return content in the correct format (`{ content: [{ type: "text", text: "..." }] }`)
  - Include error handling for all tools

  ```javascript
  // ✅ DO: Use proper tool registration pattern with Zod
  import { z } from "zod";

  server.tool(
    "context_manager",
    z.object({
      operation: z.enum(["start", "end", "create_checkpoint"]),
      focus: z.object({ entity_id: z.string() }).optional()
    }),
    async (params) => {
      try {
        // Tool implementation
        return {
          content: [{ type: "text", text: JSON.stringify({ result: "success" }) }]
        };
      } catch (error) {
        return {
          content: [{ type: "text", text: JSON.stringify({ error: error.message }) }]
        };
      }
    }
  );

  // ❌ DON'T: Skip validation or return incorrect format
  server.tool("context_manager", {}, async (params) => {
    // No schema validation
    return { result: "success" }; // Wrong return format
  });
  ```

- **Resource Implementation**
  - Use ResourceTemplate for dynamic resources
  - Include proper URI validation
  - Always return the correct contents format
  - Add appropriate caching headers where possible

  ```javascript
  // ✅ DO: Use ResourceTemplate for dynamic resources
  import { ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";

  server.resource(
    "knowledge",
    new ResourceTemplate("knowledge://{entityId}", { list: undefined }),
    async (uri, { entityId }) => ({
      contents: [{
        uri: uri.href,
        text: `Entity content for ${entityId}`,
        headers: { "cache-control": "max-age=300" }
      }]
    })
  );
  ```

- **Error Handling Patterns**
  - Use try/catch blocks in all async handlers
  - Return structured error responses in tool handlers
  - Log errors with contextual information
  - Use centralized error logging to your database

  ```javascript
  // ✅ DO: Implement comprehensive error handling
  try {
    // Implementation
  } catch (error) {
    console.error("Error in context manager:", error);
    await dbManager.execute(
      `INSERT INTO logs (id, level, message, component, details, timestamp)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [generateUUID(), "ERROR", error.message, "contextManager", 
       JSON.stringify({ stack: error.stack }), Date.now()]
    );
    throw error; // Or return formatted error response for tools
  }
  ```

- **Database Interaction**
  - Use parameterized queries to prevent SQL injection
  - Handle database connection initialization properly
  - Implement transactions for multi-step operations
  - Add appropriate error handling for database operations

  ```javascript
  // ✅ DO: Use parameterized queries and transactions
  async function updateEntities(entities) {
    return await dbManager.transaction(async () => {
      for (const entity of entities) {
        await dbManager.execute(
          "UPDATE knowledge_entities SET importance = ? WHERE id = ?",
          [entity.importance, entity.id]
        );
      }
    });
  }

  // ❌ DON'T: Use string concatenation for queries or skip transactions
  function updateEntity(entity) {
    return dbManager.execute(
      `UPDATE knowledge_entities SET importance = ${entity.importance} WHERE id = '${entity.id}'`
    );
  }
  ```

- **Vector Operations**
  - Use the correct vector dimensions (384 for MiniLM-L6-v2)
  - Implement proper vector normalization
  - Use TursoDB's vector_distance_cos for similarity search
  - Efficiently batch vector operations where possible

  ```javascript
  // ✅ DO: Use proper vector operations with TursoDB
  const results = await dbManager.execute(`
    SELECT ke.*, vector_distance_cos(ke_emb.embedding, vector32(?)) as distance
    FROM knowledge_entities ke
    JOIN knowledge_embeddings ke_emb ON ke.id = ke_emb.entity_id
    WHERE ke.entity_type IN ('file', 'class', 'function')
    ORDER BY distance ASC
    LIMIT ?
  `, [JSON.stringify(queryEmbedding), limit]);
  ```

- **Module Structure**
  - Use ES Modules with explicit extensions (.js)
  - Export classes and functions consistently
  - Structure the project with clear domain separation
  - Use dependency injection for services

  ```javascript
  // ✅ DO: Use proper ES Module imports and exports
  import { DatabaseManager } from "./services/DatabaseManager.js";
  import { generateUUID } from "./utils/uuidGenerator.js";

  export class SessionManager {
    constructor(dbManager, contextPrioritizer) {
      this.db = dbManager;
      this.contextPrioritizer = contextPrioritizer;
    }
    // Implementation
  }

  // ❌ DON'T: Use CommonJS patterns or skip extensions
  const DatabaseManager = require("./services/DatabaseManager");
  import { generateUUID } from "./utils/uuidGenerator";
  ```

- **API Response Format**
  - Return JSON-formatted text for tool responses
  - Include appropriate metadata in all responses
  - Use consistent property naming
  - Add descriptive success/error messages

  ```javascript
  // ✅ DO: Consistent JSON response format for tools
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: "Operation completed successfully",
        entity_count: entities.length,
        timestamp: Date.now()
      })
    }]
  };
  ```

- **Performance Optimization**
  - Implement caching for expensive operations
  - Use batch operations for database and embeddings
  - Consider asynchronous processing for non-critical operations
  - Monitor and optimize memory usage for vector operations

  ```javascript
  // ✅ DO: Implement caching and batch processing
  const cachedResult = cacheManager.get(cacheKey);
  if (cachedResult) return cachedResult;
  
  const result = await expensiveOperation();
  cacheManager.set(cacheKey, result);
  return result;
  ```
