---
description: Comprehensive Memory System Overview
globs: **/*
alwaysApply: true
---
# MCP Memory System Overview

This document provides a comprehensive overview of how the MCP memory system rules work together to create a sophisticated context management system.

## System Architecture

The MCP memory system consists of four primary memory layers, all managed through specific MCP tools:

1. **Working Memory**

   - Short-term storage for recently accessed code chunks and context
   - Managed primarily through the `mcp_cursor10x_mcp_capture_code` and `mcp_cursor10x_mcp_init_context` tools
   - Subject to time-based expiration and importance-based retention

2. **Semantic Memory**

   - Vector-indexed storage for code, documentation, and knowledge
   - Accessed via `mcp_cursor10x_mcp_hybrid_search` for context retrieval
   - Populated from summarized working memory and conversation memory

3. **Episodic Memory**

   - Chronological log of actions and events in the session
   - Tracked using episode recording
   - Used to understand the history of user interactions

4. **Procedural Patterns**
   - Learned representations of common coding patterns
   - Gradually reinforced throughout sessions
   - Promoted to global repository via the `mcp_cursor10x_mcp_process_memory` tool

## Core Rules Integration

The MCP memory system rules are organized into five main files that work together:

1. **150-mcp-memory-system.mdc**: Core definitions for all MCP memory tools
2. **151-mcp-session-triggers.mdc**: Session lifecycle event handling
3. **152-mcp-code-capture.mdc**: Code file change monitoring
4. **153-mcp-conversation.mdc**: Conversation context management
5. **154-mcp-memory-management.mdc**: Memory optimization and pattern learning

## Performance Optimization

The rules are optimized for performance by following these principles:

- **Strategic Timing**: Tools are called at optimal moments to avoid latency
- **Importance-Based Prioritization**: Higher priority for critical operations
- **Progressive Loading**: mcp_cursor10x_mcp_init_context uses progressive mode for fast startup
- **Background Processing**: Intensive operations are deferred to background
- **Periodic Maintenance**: Memory consolidation runs during idle periods

## Performance Targets

All tool invocations respect these performance targets:

- **mcp_cursor10x_mcp_init_context**: <150ms for initial context retrieval
- **mcp_cursor10x_mcp_capture_code**: <50ms for synchronous processing
- **mcp_cursor10x_mcp_hybrid_search**: <120ms for context retrieval
- **mcp_cursor10x_mcp_finalize_session**: <300ms for checkpoint saving

## Command Reference

Here are the key MCP tools referenced in the rules:

```javascript
// Session lifecycle
mcp_cursor10x_mcp_init_context(session_id, [priority], [mode])
mcp_cursor10x_mcp_finalize_session(session_id, [options])

// Code management
mcp_cursor10x_mcp_capture_code(session_id, file_path, code_content, [priority])

// Context retrieval
mcp_cursor10x_mcp_hybrid_search(query, sessionId, [options])

// Conversation management
mcp_cursor10x_mcp_store_conversation(session_id, messages, [summarize], [summary_type])

// Memory processing
mcp_cursor10x_mcp_process_memory(session_id, operation, [options])
```

## Best Practices

For optimal memory system operation, follow these best practices:

1. **Always Initialize**: Begin each session with mcp_cursor10x_mcp_init_context
2. **Capture Code Efficiently**: Use debouncing when capturing code changes
3. **Store Conversations**: Record both user and assistant messages
4. **Use Hybrid Search Selectively**: Only when project context is needed
5. **Manage Long Conversations**: Use periodic summarization
6. **Remember Session End**: Always finalize to preserve context

## Memory System Workflow

A typical workflow through the memory system:

1. Session begins → mcp_cursor10x_mcp_init_context loads previous state and relevant context
2. Code files change → mcp_cursor10x_mcp_capture_code adds to working memory
3. Conversation occurs → mcp_cursor10x_mcp_store_conversation tracks user and assistant messages
4. Context needed → mcp_cursor10x_mcp_hybrid_search retrieves relevant information
5. Long session → mcp_cursor10x_mcp_process_memory consolidates and optimizes memory
6. Session ends → mcp_cursor10x_mcp_finalize_session saves state for next time

## Importance Guidelines

When determining importance levels for memory items:

- **Low (0.3)**: General information, routine operations
- **Medium (0.5-0.7)**: Useful context, standard work
- **High (0.8-0.9)**: Critical decisions, major features
- **Critical (1.0)**: Core architecture, security, data-integrity

## Troubleshooting

If memory system issues occur:

1. Check system health with checkHealth()
2. Review memory statistics with getMemoryStats()
3. Ensure all tool calls are properly formatted
4. Verify session IDs are consistent throughout a session
5. Check for excessive memory consumption in long sessions
